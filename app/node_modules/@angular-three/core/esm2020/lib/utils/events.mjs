/**
 * From r3f https://github.com/pmndrs/react-three-fiber/blob/master/packages/fiber/src/core/events.ts
 */
import * as THREE from 'three';
import { makeId } from './make-id';
/** Release pointer captures.
 * This is called by releasePointerCapture in the API, and when an object is removed.
 */
function releaseInternalPointerCapture(capturedMap, obj, captures, pointerId) {
    const captureData = captures.get(obj);
    if (captureData) {
        captures.delete(obj);
        // If this was the last capturing object for this pointer
        if (captures.size === 0) {
            capturedMap.delete(pointerId);
            captureData.target.releasePointerCapture(pointerId);
        }
    }
}
export function removeInteractivity(eventsStateGetter, object) {
    const { internal } = eventsStateGetter();
    // Removes every trace of an object from the data store
    internal.interaction = internal.interaction.filter((o) => o !== object);
    internal.initialHits = internal.initialHits.filter((o) => o !== object);
    internal.hovered.forEach((value, key) => {
        if (value.eventObject === object || value.object === object) {
            internal.hovered.delete(key);
        }
    });
    internal.capturedMap.forEach((captures, pointerId) => {
        releaseInternalPointerCapture(internal.capturedMap, object, captures, pointerId);
    });
}
function getRenderState(state) {
    const { mouse, camera, clock, renderer, scene, size, viewport } = state;
    const delta = clock.getDelta();
    return {
        size,
        mouse,
        camera: camera,
        delta,
        clock,
        renderer: renderer,
        scene: scene,
        viewport,
    };
}
export function createEvents(stateGetter, eventsStateGetter) {
    const temp = new THREE.Vector3();
    /** Sets up defaultRaycaster */
    function prepareRay(event) {
        const state = stateGetter();
        const { raycaster, mouse, camera, size } = state;
        // https://github.com/pmndrs/react-three-fiber/pull/782
        // Events trigger outside of canvas when moved
        if (raycaster && camera) {
            const { offsetX, offsetY } = raycaster?.computeOffsets?.(event, getRenderState(state)) ?? event;
            const { width, height } = size;
            mouse.set((offsetX / width) * 2 - 1, -(offsetY / height) * 2 + 1);
            raycaster.setFromCamera(mouse, camera);
        }
    }
    /** Calculates delta */
    function calculateDistance(event) {
        const { internal } = eventsStateGetter();
        const dx = event.offsetX - internal.initialClick[0];
        const dy = event.offsetY - internal.initialClick[1];
        return Math.round(Math.sqrt(dx * dx + dy * dy));
    }
    /** Returns true if an instance has a valid pointer-event registered, this excludes scroll, clicks etc */
    function filterPointerEvents(objects) {
        return objects.filter((obj) => ['move', 'over', 'enter', 'out', 'leave'].some((name) => obj.__ngt?.handlers?.[('pointer' + name)]));
    }
    function intersect(filter) {
        const canvasState = stateGetter();
        const { internal } = eventsStateGetter();
        const { raycaster } = canvasState;
        // Skip event handling when noEvents is set
        if (!raycaster?.enabled)
            return [];
        const seen = new Set();
        const intersections = [];
        // Allow callers to eliminate event objects
        const eventsObjects = filter
            ? filter(internal.interaction)
            : internal.interaction;
        // Intersect known handler objects and filter against duplicates
        let intersects = raycaster
            .intersectObjects(eventsObjects, true)
            .filter((item) => {
            const id = makeId(item);
            if (seen.has(id))
                return false;
            seen.add(id);
            return true;
        });
        // https://github.com/mrdoob/three.js/issues/16031
        // Allow custom userland intersect sort order
        if (raycaster.filter)
            intersects = raycaster.filter(intersects, getRenderState(canvasState));
        for (const intersect of intersects) {
            let eventObject = intersect.object;
            // Bubble event up
            while (eventObject) {
                if (eventObject.__ngt?.eventCount)
                    intersections.push({ ...intersect, eventObject });
                eventObject = eventObject.parent;
            }
        }
        return intersections;
    }
    /**  Creates filtered intersects and returns an array of positive hits */
    function patchIntersects(intersections, event) {
        const { internal } = eventsStateGetter();
        // If the interaction is captured, make all capturing targets  part of the
        // intersect.
        if ('pointerId' in event && internal.capturedMap.has(event.pointerId)) {
            for (let captureData of internal.capturedMap
                .get(event.pointerId)
                .values()) {
                intersections.push(captureData.intersection);
            }
        }
        return intersections;
    }
    function cancelPointer(hits) {
        const { internal } = eventsStateGetter();
        Array.from(internal.hovered.values()).forEach((hoveredObj) => {
            // When no objects were hit or the the hovered object wasn't found underneath the cursor
            // we call onPointerOut and delete the object from the hovered-elements map
            if (!hits.length ||
                !hits.find((hit) => hit.object === hoveredObj.object &&
                    hit.index === hoveredObj.index &&
                    hit.instanceId === hoveredObj.instanceId)) {
                const eventObject = hoveredObj.eventObject;
                const instance = eventObject.__ngt;
                const handlers = instance?.handlers;
                internal.hovered.delete(makeId(hoveredObj));
                if (instance?.eventCount) {
                    // Clear out intersects, they are outdated by now
                    const data = { ...hoveredObj, intersections: hits || [] };
                    handlers?.pointerout?.(data);
                    handlers?.pointerleave?.(data);
                }
            }
        });
    }
    /**  Handles intersections by forwarding them to handlers */
    function handleIntersects(intersections, event, delta, callback) {
        const { raycaster, mouse, camera } = stateGetter();
        const { internal } = eventsStateGetter();
        // If anything has been found, forward it to the event listeners
        if (intersections.length && camera) {
            const unprojectedPoint = temp.set(mouse.x, mouse.y, 0).unproject(camera);
            const localState = { stopped: false };
            for (const hit of intersections) {
                const hasPointerCapture = (id) => internal.capturedMap.get(id)?.has(hit.eventObject) ?? false;
                const setPointerCapture = (id) => {
                    const captureData = {
                        intersection: hit,
                        target: event.target,
                    };
                    if (internal.capturedMap.has(id)) {
                        // if the pointerId was previously captured, we add the hit to the
                        // event capturedMap.
                        internal.capturedMap.get(id).set(hit.eventObject, captureData);
                    }
                    else {
                        // if the pointerId was not previously captured, we create a map
                        // containing the hitObject, and the hit. hitObject is used for
                        // faster access.
                        internal.capturedMap.set(id, new Map([[hit.eventObject, captureData]]));
                    }
                    // Call the original event now
                    event.target.setPointerCapture(id);
                };
                const releasePointerCapture = (id) => {
                    const captures = internal.capturedMap.get(id);
                    if (captures) {
                        releaseInternalPointerCapture(internal.capturedMap, hit.eventObject, captures, id);
                    }
                };
                // Add native event props
                let extractEventProps = {};
                // This iterates over the event's properties including the inherited ones. Native PointerEvents have most of their props as getters which are inherited, but polyfilled PointerEvents have them all as their own properties (i.e. not inherited). We can't use Object.keys() or Object.entries() as they only return "own" properties; nor Object.getPrototypeOf(event) as that *doesn't* return "own" properties, only inherited ones.
                for (let prop in event) {
                    let property = event[prop];
                    // Only copy over atomics, leave functions alone as these should be
                    // called as event.nativeEvent.fn()
                    if (typeof property !== 'function')
                        extractEventProps[prop] = property;
                }
                let raycastEvent = {
                    ...hit,
                    ...extractEventProps,
                    spaceX: mouse.x,
                    spaceY: mouse.y,
                    intersections,
                    stopped: localState.stopped,
                    delta,
                    unprojectedPoint,
                    ray: raycaster?.ray,
                    camera: camera,
                    // Hijack stopPropagation, which just sets a flag
                    stopPropagation: () => {
                        // https://github.com/pmndrs/react-three-fiber/issues/596
                        // Events are not allowed to stop propagation if the pointer has been captured
                        const capturesForPointer = 'pointerId' in event && internal.capturedMap.get(event.pointerId);
                        // We only authorize stopPropagation...
                        if (
                        // ...if this pointer hasn't been captured
                        !capturesForPointer ||
                            // ... or if the hit object is capturing the pointer
                            capturesForPointer.has(hit.eventObject)) {
                            raycastEvent.stopped = localState.stopped = true;
                            // Propagation is stopped, remove all other hover records
                            // An event handler is only allowed to flush other handlers if it is hovered itself
                            if (internal.hovered.size &&
                                Array.from(internal.hovered.values()).find((i) => i.eventObject === hit.eventObject)) {
                                // Objects cannot flush out higher up objects that have already caught the event
                                const higher = intersections.slice(0, intersections.indexOf(hit));
                                cancelPointer([...higher, hit]);
                            }
                        }
                    },
                    // there should be a distinction between target and currentTarget
                    target: {
                        hasPointerCapture,
                        setPointerCapture,
                        releasePointerCapture,
                    },
                    currentTarget: {
                        hasPointerCapture,
                        setPointerCapture,
                        releasePointerCapture,
                    },
                    sourceEvent: event,
                    nativeEvent: event,
                };
                // Call subscribers
                callback(raycastEvent);
                // Event bubbling may be interrupted by stopPropagation
                if (localState.stopped)
                    break;
            }
        }
        return intersections;
    }
    const handlePointer = (name) => {
        // Deal with cancelation
        switch (name) {
            case 'pointerleave':
            case 'pointercancel':
                return () => cancelPointer([]);
            case 'onLostPointerCapture':
                return (event) => {
                    if ('pointerId' in event) {
                        // If the object event interface had onLostPointerCapture, we'd call it here on every
                        // object that's getting removed.
                        const { internal: { capturedMap }, } = eventsStateGetter();
                        capturedMap.delete(event.pointerId);
                    }
                    cancelPointer([]);
                };
        }
        // Any other pointer goes here ...
        return (event) => {
            const { pointerMissed, internal } = eventsStateGetter();
            prepareRay(event);
            // Get fresh intersects
            const isPointerMove = name === 'pointermove';
            const isClickEvent = name === 'click' || name === 'contextmenu' || name === 'dblclick';
            const filter = isPointerMove ? filterPointerEvents : undefined;
            const hits = patchIntersects(intersect(filter), event);
            const delta = isClickEvent ? calculateDistance(event) : 0;
            // Save initial coordinates on pointer-down
            if (name === 'pointerdown') {
                internal.initialClick = [event.offsetX, event.offsetY];
                internal.initialHits = hits.map((hit) => hit.eventObject);
            }
            // If a click yields no results, pass it back to the user as a miss
            // Missed events have to come first in order to establish user-land side-effect clean up
            if (isClickEvent && !hits.length) {
                if (delta <= 2) {
                    objectPointerMissed(event, internal.interaction);
                    if (pointerMissed)
                        pointerMissed(event);
                }
            }
            // Take care of unhover
            if (isPointerMove)
                cancelPointer(hits);
            handleIntersects(hits, event, delta, (data) => {
                const eventObject = data.eventObject;
                const instance = eventObject.__ngt;
                const handlers = instance?.handlers;
                // Check presence of handlers
                if (!instance?.eventCount)
                    return;
                if (isPointerMove) {
                    // Move event ...
                    if (handlers?.pointerover ||
                        handlers?.pointerenter ||
                        handlers?.pointerout ||
                        handlers?.pointerleave) {
                        // When enter or out is present take care of hover-state
                        const id = makeId(data);
                        const hoveredItem = internal.hovered.get(id);
                        if (!hoveredItem) {
                            // If the object wasn't previously hovered, book it and call its handler
                            internal.hovered.set(id, data);
                            handlers.pointerover?.(data);
                            handlers.pointerenter?.(data);
                        }
                        else if (hoveredItem.stopped) {
                            // If the object was previously hovered and stopped, we shouldn't allow other items to proceed
                            data.stopPropagation();
                        }
                    }
                    // Call mouse move
                    handlers?.pointermove?.(data);
                }
                else {
                    // All other events ...
                    const handler = handlers?.[name];
                    if (handler) {
                        // Forward all events back to their respective handlers with the exception of click events,
                        // which must use the initial target
                        if (!isClickEvent || internal.initialHits.includes(eventObject)) {
                            // Missed events have to come first
                            objectPointerMissed(event, internal.interaction.filter((object) => !internal.initialHits.includes(object)));
                            // Now call the handler
                            handler(data);
                        }
                    }
                }
            });
        };
    };
    function objectPointerMissed(event, objects) {
        objects.forEach((object) => object.__ngt?.handlers?.pointermissed?.(event));
    }
    return { handlePointer };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXZlbnRzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvY29yZS9zcmMvbGliL3V0aWxzL2V2ZW50cy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7R0FFRztBQUVILE9BQU8sS0FBSyxLQUFLLE1BQU0sT0FBTyxDQUFDO0FBYS9CLE9BQU8sRUFBRSxNQUFNLEVBQUUsTUFBTSxXQUFXLENBQUM7QUFFbkM7O0dBRUc7QUFDSCxTQUFTLDZCQUE2QixDQUNwQyxXQUFzRSxFQUN0RSxHQUFtQixFQUNuQixRQUFzRCxFQUN0RCxTQUFpQjtJQUVqQixNQUFNLFdBQVcsR0FBd0MsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUMzRSxJQUFJLFdBQVcsRUFBRTtRQUNmLFFBQVEsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDckIseURBQXlEO1FBQ3pELElBQUksUUFBUSxDQUFDLElBQUksS0FBSyxDQUFDLEVBQUU7WUFDdkIsV0FBVyxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsQ0FBQztZQUM5QixXQUFXLENBQUMsTUFBTSxDQUFDLHFCQUFxQixDQUFDLFNBQVMsQ0FBQyxDQUFDO1NBQ3JEO0tBQ0Y7QUFDSCxDQUFDO0FBRUQsTUFBTSxVQUFVLG1CQUFtQixDQUNqQyxpQkFBNEMsRUFDNUMsTUFBc0I7SUFFdEIsTUFBTSxFQUFFLFFBQVEsRUFBRSxHQUFHLGlCQUFpQixFQUFFLENBQUM7SUFDekMsdURBQXVEO0lBQ3ZELFFBQVEsQ0FBQyxXQUFXLEdBQUcsUUFBUSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsS0FBSyxNQUFNLENBQUMsQ0FBQztJQUN4RSxRQUFRLENBQUMsV0FBVyxHQUFHLFFBQVEsQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLEtBQUssTUFB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QUFZLElBQUksUUFBUSxDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsV0FBVyxDQUFDLEVBQUU7NEJBQy9ELG1DQUFtQzs0QkFDbkMsbUJBQW1CLENBQ2pCLEtBQUssRUFDTCxRQUFRLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FDekIsQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLENBQ25ELENBQ0YsQ0FBQzs0QkFDRix1QkFBdUI7NEJBQ3ZCLE9BQU8sQ0FBQyxJQUE4QixDQUFDLENBQUM7eUJBQ3pDO3FCQUNGO2lCQUNGO1lBQ0gsQ0FBQyxDQUFDLENBQUM7UUFDTCxDQUFDLENBQUM7SUFDSixDQUFDLENBQUM7SUFFRixTQUFTLG1CQUFtQixDQUFDLEtBQWlCLEVBQUUsT0FBeUI7UUFDdkUsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDLE1BQXNCLEVBQUUsRUFBRSxDQUN4QyxNQUFpQyxDQUFDLEtBQUssRUFBRSxRQUFRLEVBQUUsYUFBYSxFQUFFLENBQUMsS0FBSyxDQUFDLENBQzNFLENBQUM7SUFDSixDQUFDO0lBRUQsT0FBTyxFQUFFLGFBQWEsRUFBRSxDQUFDO0FBQzNCLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEZyb20gcjNmIGh0dHBzOi8vZ2l0aHViLmNvbS9wbW5kcnMvcmVhY3QtdGhyZWUtZmliZXIvYmxvYi9tYXN0ZXIvcGFja2FnZXMvZmliZXIvc3JjL2NvcmUvZXZlbnRzLnRzXG4gKi9cblxuaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAndGhyZWUnO1xuaW1wb3J0IHR5cGUge1xuICBOZ3RDYW1lcmEsXG4gIE5ndERvbUV2ZW50LFxuICBOZ3RFdmVudCxcbiAgTmd0RXZlbnRIYW5kbGVycyxcbiAgTmd0RXZlbnRzU3RvcmVTdGF0ZSxcbiAgTmd0SW5zdGFuY2UsXG4gIE5ndEludGVyc2VjdGlvbixcbiAgTmd0UG9pbnRlckNhcHR1cmVUYXJnZXQsXG4gIE5ndFJlbmRlcixcbiAgTmd0U3RhdGUsXG59IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IG1ha2VJZCB9IGZyb20gJy4vbWFrZS1pZCc7XG5cbi8qKiBSZWxlYXNlIHBvaW50ZXIgY2FwdHVyZXMuXG4gKiBUaGlzIGlzIGNhbGxlZCBieSByZWxlYXNlUG9pbnRlckNhcHR1cmUgaW4gdGhlIEFQSSwgYW5kIHdoZW4gYW4gb2JqZWN0IGlzIHJlbW92ZWQuXG4gKi9cbmZ1bmN0aW9uIHJlbGVhc2VJbnRlcm5hbFBvaW50ZXJDYXB0dXJlKFxuICBjYXB0dXJlZE1hcDogTWFwPG51bWJlciwgTWFwPFRIUkVFLk9iamVjdDNELCBOZ3RQb2ludGVyQ2FwdHVyZVRhcmdldD4+LFxuICBvYmo6IFRIUkVFLk9iamVjdDNELFxuICBjYXB0dXJlczogTWFwPFRIUkVFLk9iamVjdDNELCBOZ3RQb2ludGVyQ2FwdHVyZVRhcmdldD4sXG4gIHBvaW50ZXJJZDogbnVtYmVyXG4pOiB2b2lkIHtcbiAgY29uc3QgY2FwdHVyZURhdGE6IE5ndFBvaW50ZXJDYXB0dXJlVGFyZ2V0IHwgdW5kZWZpbmVkID0gY2FwdHVyZXMuZ2V0KG9iaik7XG4gIGlmIChjYXB0dXJlRGF0YSkge1xuICAgIGNhcHR1cmVzLmRlbGV0ZShvYmopO1xuICAgIC8vIElmIHRoaXMgd2FzIHRoZSBsYXN0IGNhcHR1cmluZyBvYmplY3QgZm9yIHRoaXMgcG9pbnRlclxuICAgIGlmIChjYXB0dXJlcy5zaXplID09PSAwKSB7XG4gICAgICBjYXB0dXJlZE1hcC5kZWxldGUocG9pbnRlcklkKTtcbiAgICAgIGNhcHR1cmVEYXRhLnRhcmdldC5yZWxlYXNlUG9pbnRlckNhcHR1cmUocG9pbnRlcklkKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUludGVyYWN0aXZpdHkoXG4gIGV2ZW50c1N0YXRlR2V0dGVyOiAoKSA9PiBOZ3RFdmVudHNTdG9yZVN0YXRlLFxuICBvYmplY3Q6IFRIUkVFLk9iamVjdDNEXG4pIHtcbiAgY29uc3QgeyBpbnRlcm5hbCB9ID0gZXZlbnRzU3RhdGVHZXR0ZXIoKTtcbiAgLy8gUmVtb3ZlcyBldmVyeSB0cmFjZSBvZiBhbiBvYmplY3QgZnJvbSB0aGUgZGF0YSBzdG9yZVxuICBpbnRlcm5hbC5pbnRlcmFjdGlvbiA9IGludGVybmFsLmludGVyYWN0aW9uLmZpbHRlcigobykgPT4gbyAhPT0gb2JqZWN0KTtcbiAgaW50ZXJuYWwuaW5pdGlhbEhpdHMgPSBpbnRlcm5hbC5pbml0aWFsSGl0cy5maWx0ZXIoKG8pID0+IG8gIT09IG9iamVjdCk7XG4gIGludGVybmFsLmhvdmVyZWQuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgIGlmICh2YWx1ZS5ldmVudE9iamVjdCA9PT0gb2JqZWN0IHx8IHZhbHVlLm9iamVjdCA9PT0gb2JqZWN0KSB7XG4gICAgICBpbnRlcm5hbC5ob3ZlcmVkLmRlbGV0ZShrZXkpO1xuICAgIH1cbiAgfSk7XG4gIGludGVybmFsLmNhcHR1cmVkTWFwLmZvckVhY2goKGNhcHR1cmVzLCBwb2ludGVySWQpID0+IHtcbiAgICByZWxlYXNlSW50ZXJuYWxQb2ludGVyQ2FwdHVyZShcbiAgICAgIGludGVybmFsLmNhcHR1cmVkTWFwLFxuICAgICAgb2JqZWN0LFxuICAgICAgY2FwdHVyZXMsXG4gICAgICBwb2ludGVySWRcbiAgICApO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0UmVuZGVyU3RhdGUoc3RhdGU6IE5ndFN0YXRlKTogTmd0UmVuZGVyIHtcbiAgY29uc3QgeyBtb3VzZSwgY2FtZXJhLCBjbG9jaywgcmVuZGVyZXIsIHNjZW5lLCBzaXplLCB2aWV3cG9ydCB9ID0gc3RhdGU7XG4gIGNvbnN0IGRlbHRhID0gY2xvY2suZ2V0RGVsdGEoKTtcblxuICByZXR1cm4ge1xuICAgIHNpemUsXG4gICAgbW91c2UsXG4gICAgY2FtZXJhOiBjYW1lcmEgYXMgTmd0Q2FtZXJhLFxuICAgIGRlbHRhLFxuICAgIGNsb2NrLFxuICAgIHJlbmRlcmVyOiByZW5kZXJlciBhcyBUSFJFRS5XZWJHTFJlbmRlcmVyLFxuICAgIHNjZW5lOiBzY2VuZSBhcyBUSFJFRS5TY2VuZSxcbiAgICB2aWV3cG9ydCxcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUV2ZW50cyhcbiAgc3RhdGVHZXR0ZXI6ICgpID0+IE5ndFN0YXRlLFxuICBldmVudHNTdGF0ZUdldHRlcjogKCkgPT4gTmd0RXZlbnRzU3RvcmVTdGF0ZVxuKSB7XG4gIGNvbnN0IHRlbXAgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gIC8qKiBTZXRzIHVwIGRlZmF1bHRSYXljYXN0ZXIgKi9cbiAgZnVuY3Rpb24gcHJlcGFyZVJheShldmVudDogTmd0RG9tRXZlbnQpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHN0YXRlR2V0dGVyKCk7XG4gICAgY29uc3QgeyByYXljYXN0ZXIsIG1vdXNlLCBjYW1lcmEsIHNpemUgfSA9IHN0YXRlO1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wbW5kcnMvcmVhY3QtdGhyZWUtZmliZXIvcHVsbC83ODJcbiAgICAvLyBFdmVudHMgdHJpZ2dlciBvdXRzaWRlIG9mIGNhbnZhcyB3aGVuIG1vdmVkXG4gICAgaWYgKHJheWNhc3RlciAmJiBjYW1lcmEpIHtcbiAgICAgIGNvbnN0IHsgb2Zmc2V0WCwgb2Zmc2V0WSB9ID1cbiAgICAgICAgcmF5Y2FzdGVyPy5jb21wdXRlT2Zmc2V0cz8uKGV2ZW50LCBnZXRSZW5kZXJTdGF0ZShzdGF0ZSkpID8/IGV2ZW50O1xuXG4gICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHNpemU7XG4gICAgICBtb3VzZS5zZXQoKG9mZnNldFggLyB3aWR0aCkgKiAyIC0gMSwgLShvZmZzZXRZIC8gaGVpZ2h0KSAqIDIgKyAxKTtcbiAgICAgIHJheWNhc3Rlci5zZXRGcm9tQ2FtZXJhKG1vdXNlLCBjYW1lcmEpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBDYWxjdWxhdGVzIGRlbHRhICovXG4gIGZ1bmN0aW9uIGNhbGN1bGF0ZURpc3RhbmNlKGV2ZW50OiBOZ3REb21FdmVudCkge1xuICAgIGNvbnN0IHsgaW50ZXJuYWwgfSA9IGV2ZW50c1N0YXRlR2V0dGVyKCk7XG4gICAgY29uc3QgZHggPSBldmVudC5vZmZzZXRYIC0gaW50ZXJuYWwuaW5pdGlhbENsaWNrWzBdO1xuICAgIGNvbnN0IGR5ID0gZXZlbnQub2Zmc2V0WSAtIGludGVybmFsLmluaXRpYWxDbGlja1sxXTtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpKTtcbiAgfVxuXG4gIC8qKiBSZXR1cm5zIHRydWUgaWYgYW4gaW5zdGFuY2UgaGFzIGEgdmFsaWQgcG9pbnRlci1ldmVudCByZWdpc3RlcmVkLCB0aGlzIGV4Y2x1ZGVzIHNjcm9sbCwgY2xpY2tzIGV0YyAqL1xuICBmdW5jdGlvbiBmaWx0ZXJQb2ludGVyRXZlbnRzKG9iamVjdHM6IFRIUkVFLk9iamVjdDNEW10pIHtcbiAgICByZXR1cm4gb2JqZWN0cy5maWx0ZXIoKG9iaikgPT5cbiAgICAgIFsnbW92ZScsICdvdmVyJywgJ2VudGVyJywgJ291dCcsICdsZWF2ZSddLnNvbWUoXG4gICAgICAgIChuYW1lKSA9PlxuICAgICAgICAgIChvYmogYXMgdW5rbm93biBhcyBOZ3RJbnN0YW5jZSkuX19uZ3Q/LmhhbmRsZXJzPy5bXG4gICAgICAgICAgICAoJ3BvaW50ZXInICsgbmFtZSkgYXMga2V5b2YgTmd0RXZlbnRIYW5kbGVyc1xuICAgICAgICAgIF1cbiAgICAgIClcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gaW50ZXJzZWN0KGZpbHRlcj86IChvYmplY3RzOiBUSFJFRS5PYmplY3QzRFtdKSA9PiBUSFJFRS5PYmplY3QzRFtdKSB7XG4gICAgY29uc3QgY2FudmFzU3RhdGUgPSBzdGF0ZUdldHRlcigpO1xuICAgIGNvbnN0IHsgaW50ZXJuYWwgfSA9IGV2ZW50c1N0YXRlR2V0dGVyKCk7XG5cbiAgICBjb25zdCB7IHJheWNhc3RlciB9ID0gY2FudmFzU3RhdGU7XG5cbiAgICAvLyBTa2lwIGV2ZW50IGhhbmRsaW5nIHdoZW4gbm9FdmVudHMgaXMgc2V0XG4gICAgaWYgKCFyYXljYXN0ZXI/LmVuYWJsZWQpIHJldHVybiBbXTtcblxuICAgIGNvbnN0IHNlZW4gPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgICBjb25zdCBpbnRlcnNlY3Rpb25zOiBOZ3RJbnRlcnNlY3Rpb25bXSA9IFtdO1xuXG4gICAgLy8gQWxsb3cgY2FsbGVycyB0byBlbGltaW5hdGUgZXZlbnQgb2JqZWN0c1xuICAgIGNvbnN0IGV2ZW50c09iamVjdHMgPSBmaWx0ZXJcbiAgICAgID8gZmlsdGVyKGludGVybmFsLmludGVyYWN0aW9uKVxuICAgICAgOiBpbnRlcm5hbC5pbnRlcmFjdGlvbjtcblxuICAgIC8vIEludGVyc2VjdCBrbm93biBoYW5kbGVyIG9iamVjdHMgYW5kIGZpbHRlciBhZ2FpbnN0IGR1cGxpY2F0ZXNcbiAgICBsZXQgaW50ZXJzZWN0cyA9IHJheWNhc3RlclxuICAgICAgLmludGVyc2VjdE9iamVjdHMoZXZlbnRzT2JqZWN0cywgdHJ1ZSlcbiAgICAgIC5maWx0ZXIoKGl0ZW0pID0+IHtcbiAgICAgICAgY29uc3QgaWQgPSBtYWtlSWQoaXRlbSBhcyBOZ3RJbnRlcnNlY3Rpb24pO1xuICAgICAgICBpZiAoc2Vlbi5oYXMoaWQpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHNlZW4uYWRkKGlkKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9KTtcblxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvaXNzdWVzLzE2MDMxXG4gICAgLy8gQWxsb3cgY3VzdG9tIHVzZXJsYW5kIGludGVyc2VjdCBzb3J0IG9yZGVyXG4gICAgaWYgKHJheWNhc3Rlci5maWx0ZXIpXG4gICAgICBpbnRlcnNlY3RzID0gcmF5Y2FzdGVyLmZpbHRlcihpbnRlcnNlY3RzLCBnZXRSZW5kZXJTdGF0ZShjYW52YXNTdGF0ZSkpO1xuXG4gICAgZm9yIChjb25zdCBpbnRlcnNlY3Qgb2YgaW50ZXJzZWN0cykge1xuICAgICAgbGV0IGV2ZW50T2JqZWN0OiBUSFJFRS5PYmplY3QzRCB8IG51bGwgPSBpbnRlcnNlY3Qub2JqZWN0O1xuICAgICAgLy8gQnViYmxlIGV2ZW50IHVwXG4gICAgICB3aGlsZSAoZXZlbnRPYmplY3QpIHtcbiAgICAgICAgaWYgKChldmVudE9iamVjdCBhcyB1bmtub3duIGFzIE5ndEluc3RhbmNlKS5fX25ndD8uZXZlbnRDb3VudClcbiAgICAgICAgICBpbnRlcnNlY3Rpb25zLnB1c2goeyAuLi5pbnRlcnNlY3QsIGV2ZW50T2JqZWN0IH0pO1xuICAgICAgICBldmVudE9iamVjdCA9IGV2ZW50T2JqZWN0LnBhcmVudDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGludGVyc2VjdGlvbnM7XG4gIH1cblxuICAvKiogIENyZWF0ZXMgZmlsdGVyZWQgaW50ZXJzZWN0cyBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiBwb3NpdGl2ZSBoaXRzICovXG4gIGZ1bmN0aW9uIHBhdGNoSW50ZXJzZWN0cyhcbiAgICBpbnRlcnNlY3Rpb25zOiBOZ3RJbnRlcnNlY3Rpb25bXSxcbiAgICBldmVudDogTmd0RG9tRXZlbnRcbiAgKSB7XG4gICAgY29uc3QgeyBpbnRlcm5hbCB9ID0gZXZlbnRzU3RhdGVHZXR0ZXIoKTtcbiAgICAvLyBJZiB0aGUgaW50ZXJhY3Rpb24gaXMgY2FwdHVyZWQsIG1ha2UgYWxsIGNhcHR1cmluZyB0YXJnZXRzICBwYXJ0IG9mIHRoZVxuICAgIC8vIGludGVyc2VjdC5cbiAgICBpZiAoJ3BvaW50ZXJJZCcgaW4gZXZlbnQgJiYgaW50ZXJuYWwuY2FwdHVyZWRNYXAuaGFzKGV2ZW50LnBvaW50ZXJJZCkpIHtcbiAgICAgIGZvciAobGV0IGNhcHR1cmVEYXRhIG9mIGludGVybmFsLmNhcHR1cmVkTWFwXG4gICAgICAgIC5nZXQoZXZlbnQucG9pbnRlcklkKSFcbiAgICAgICAgLnZhbHVlcygpKSB7XG4gICAgICAgIGludGVyc2VjdGlvbnMucHVzaChjYXB0dXJlRGF0YS5pbnRlcnNlY3Rpb24pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaW50ZXJzZWN0aW9ucztcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbmNlbFBvaW50ZXIoaGl0czogTmd0SW50ZXJzZWN0aW9uW10pIHtcbiAgICBjb25zdCB7IGludGVybmFsIH0gPSBldmVudHNTdGF0ZUdldHRlcigpO1xuICAgIEFycmF5LmZyb20oaW50ZXJuYWwuaG92ZXJlZC52YWx1ZXMoKSkuZm9yRWFjaCgoaG92ZXJlZE9iaikgPT4ge1xuICAgICAgLy8gV2hlbiBubyBvYmplY3RzIHdlcmUgaGl0IG9yIHRoZSB0aGUgaG92ZXJlZCBvYmplY3Qgd2Fzbid0IGZvdW5kIHVuZGVybmVhdGggdGhlIGN1cnNvclxuICAgICAgLy8gd2UgY2FsbCBvblBvaW50ZXJPdXQgYW5kIGRlbGV0ZSB0aGUgb2JqZWN0IGZyb20gdGhlIGhvdmVyZWQtZWxlbWVudHMgbWFwXG4gICAgICBpZiAoXG4gICAgICAgICFoaXRzLmxlbmd0aCB8fFxuICAgICAgICAhaGl0cy5maW5kKFxuICAgICAgICAgIChoaXQpID0+XG4gICAgICAgICAgICBoaXQub2JqZWN0ID09PSBob3ZlcmVkT2JqLm9iamVjdCAmJlxuICAgICAgICAgICAgaGl0LmluZGV4ID09PSBob3ZlcmVkT2JqLmluZGV4ICYmXG4gICAgICAgICAgICBoaXQuaW5zdGFuY2VJZCA9PT0gaG92ZXJlZE9iai5pbnN0YW5jZUlkXG4gICAgICAgIClcbiAgICAgICkge1xuICAgICAgICBjb25zdCBldmVudE9iamVjdCA9IGhvdmVyZWRPYmouZXZlbnRPYmplY3Q7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gKGV2ZW50T2JqZWN0IGFzIHVua25vd24gYXMgTmd0SW5zdGFuY2UpLl9fbmd0O1xuICAgICAgICBjb25zdCBoYW5kbGVycyA9IGluc3RhbmNlPy5oYW5kbGVycztcbiAgICAgICAgaW50ZXJuYWwuaG92ZXJlZC5kZWxldGUobWFrZUlkKGhvdmVyZWRPYmopKTtcbiAgICAgICAgaWYgKGluc3RhbmNlPy5ldmVudENvdW50KSB7XG4gICAgICAgICAgLy8gQ2xlYXIgb3V0IGludGVyc2VjdHMsIHRoZXkgYXJlIG91dGRhdGVkIGJ5IG5vd1xuICAgICAgICAgIGNvbnN0IGRhdGEgPSB7IC4uLmhvdmVyZWRPYmosIGludGVyc2VjdGlvbnM6IGhpdHMgfHwgW10gfTtcbiAgICAgICAgICBoYW5kbGVycz8ucG9pbnRlcm91dD8uKGRhdGEgYXMgTmd0RXZlbnQ8UG9pbnRlckV2ZW50Pik7XG4gICAgICAgICAgaGFuZGxlcnM/LnBvaW50ZXJsZWF2ZT8uKGRhdGEgYXMgTmd0RXZlbnQ8UG9pbnRlckV2ZW50Pik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKiAgSGFuZGxlcyBpbnRlcnNlY3Rpb25zIGJ5IGZvcndhcmRpbmcgdGhlbSB0byBoYW5kbGVycyAqL1xuICBmdW5jdGlvbiBoYW5kbGVJbnRlcnNlY3RzKFxuICAgIGludGVyc2VjdGlvbnM6IE5ndEludGVyc2VjdGlvbltdLFxuICAgIGV2ZW50OiBOZ3REb21FdmVudCxcbiAgICBkZWx0YTogbnVtYmVyLFxuICAgIGNhbGxiYWNrOiAoZXZlbnQ6IE5ndEV2ZW50PE5ndERvbUV2ZW50PikgPT4gdm9pZFxuICApIHtcbiAgICBjb25zdCB7IHJheWNhc3RlciwgbW91c2UsIGNhbWVyYSB9ID0gc3RhdGVHZXR0ZXIoKTtcbiAgICBjb25zdCB7IGludGVybmFsIH0gPSBldmVudHNTdGF0ZUdldHRlcigpO1xuICAgIC8vIElmIGFueXRoaW5nIGhhcyBiZWVuIGZvdW5kLCBmb3J3YXJkIGl0IHRvIHRoZSBldmVudCBsaXN0ZW5lcnNcbiAgICBpZiAoaW50ZXJzZWN0aW9ucy5sZW5ndGggJiYgY2FtZXJhKSB7XG4gICAgICBjb25zdCB1bnByb2plY3RlZFBvaW50ID0gdGVtcC5zZXQobW91c2UueCwgbW91c2UueSwgMCkudW5wcm9qZWN0KGNhbWVyYSk7XG5cbiAgICAgIGNvbnN0IGxvY2FsU3RhdGUgPSB7IHN0b3BwZWQ6IGZhbHNlIH07XG5cbiAgICAgIGZvciAoY29uc3QgaGl0IG9mIGludGVyc2VjdGlvbnMpIHtcbiAgICAgICAgY29uc3QgaGFzUG9pbnRlckNhcHR1cmUgPSAoaWQ6IG51bWJlcikgPT5cbiAgICAgICAgICBpbnRlcm5hbC5jYXB0dXJlZE1hcC5nZXQoaWQpPy5oYXMoaGl0LmV2ZW50T2JqZWN0KSA/PyBmYWxzZTtcblxuICAgICAgICBjb25zdCBzZXRQb2ludGVyQ2FwdHVyZSA9IChpZDogbnVtYmVyKSA9PiB7XG4gICAgICAgICAgY29uc3QgY2FwdHVyZURhdGEgPSB7XG4gICAgICAgICAgICBpbnRlcnNlY3Rpb246IGhpdCxcbiAgICAgICAgICAgIHRhcmdldDogZXZlbnQudGFyZ2V0IGFzIEVsZW1lbnQsXG4gICAgICAgICAgfTtcbiAgICAgICAgICBpZiAoaW50ZXJuYWwuY2FwdHVyZWRNYXAuaGFzKGlkKSkge1xuICAgICAgICAgICAgLy8gaWYgdGhlIHBvaW50ZXJJZCB3YXMgcHJldmlvdXNseSBjYXB0dXJlZCwgd2UgYWRkIHRoZSBoaXQgdG8gdGhlXG4gICAgICAgICAgICAvLyBldmVudCBjYXB0dXJlZE1hcC5cbiAgICAgICAgICAgIGludGVybmFsLmNhcHR1cmVkTWFwLmdldChpZCkhLnNldChoaXQuZXZlbnRPYmplY3QsIGNhcHR1cmVEYXRhKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaWYgdGhlIHBvaW50ZXJJZCB3YXMgbm90IHByZXZpb3VzbHkgY2FwdHVyZWQsIHdlIGNyZWF0ZSBhIG1hcFxuICAgICAgICAgICAgLy8gY29udGFpbmluZyB0aGUgaGl0T2JqZWN0LCBhbmQgdGhlIGhpdC4gaGl0T2JqZWN0IGlzIHVzZWQgZm9yXG4gICAgICAgICAgICAvLyBmYXN0ZXIgYWNjZXNzLlxuICAgICAgICAgICAgaW50ZXJuYWwuY2FwdHVyZWRNYXAuc2V0KFxuICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgbmV3IE1hcChbW2hpdC5ldmVudE9iamVjdCwgY2FwdHVyZURhdGFdXSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIENhbGwgdGhlIG9yaWdpbmFsIGV2ZW50IG5vd1xuICAgICAgICAgIChldmVudC50YXJnZXQgYXMgRWxlbWVudCkuc2V0UG9pbnRlckNhcHR1cmUoaWQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IHJlbGVhc2VQb2ludGVyQ2FwdHVyZSA9IChpZDogbnVtYmVyKSA9PiB7XG4gICAgICAgICAgY29uc3QgY2FwdHVyZXMgPSBpbnRlcm5hbC5jYXB0dXJlZE1hcC5nZXQoaWQpO1xuICAgICAgICAgIGlmIChjYXB0dXJlcykge1xuICAgICAgICAgICAgcmVsZWFzZUludGVybmFsUG9pbnRlckNhcHR1cmUoXG4gICAgICAgICAgICAgIGludGVybmFsLmNhcHR1cmVkTWFwLFxuICAgICAgICAgICAgICBoaXQuZXZlbnRPYmplY3QsXG4gICAgICAgICAgICAgIGNhcHR1cmVzLFxuICAgICAgICAgICAgICBpZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQWRkIG5hdGl2ZSBldmVudCBwcm9wc1xuICAgICAgICBsZXQgZXh0cmFjdEV2ZW50UHJvcHM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+ID0ge307XG4gICAgICAgIC8vIFRoaXMgaXRlcmF0ZXMgb3ZlciB0aGUgZXZlbnQncyBwcm9wZXJ0aWVzIGluY2x1ZGluZyB0aGUgaW5oZXJpdGVkIG9uZXMuIE5hdGl2ZSBQb2ludGVyRXZlbnRzIGhhdmUgbW9zdCBvZiB0aGVpciBwcm9wcyBhcyBnZXR0ZXJzIHdoaWNoIGFyZSBpbmhlcml0ZWQsIGJ1dCBwb2x5ZmlsbGVkIFBvaW50ZXJFdmVudHMgaGF2ZSB0aGVtIGFsbCBhcyB0aGVpciBvd24gcHJvcGVydGllcyAoaS5lLiBub3QgaW5oZXJpdGVkKS4gV2UgY2FuJ3QgdXNlIE9iamVjdC5rZXlzKCkgb3IgT2JqZWN0LmVudHJpZXMoKSBhcyB0aGV5IG9ubHkgcmV0dXJuIFwib3duXCIgcHJvcGVydGllczsgbm9yIE9iamVjdC5nZXRQcm90b3R5cGVPZihldmVudCkgYXMgdGhhdCAqZG9lc24ndCogcmV0dXJuIFwib3duXCIgcHJvcGVydGllcywgb25seSBpbmhlcml0ZWQgb25lcy5cbiAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBldmVudCkge1xuICAgICAgICAgIGxldCBwcm9wZXJ0eSA9IGV2ZW50W3Byb3AgYXMga2V5b2YgTmd0RG9tRXZlbnRdO1xuICAgICAgICAgIC8vIE9ubHkgY29weSBvdmVyIGF0b21pY3MsIGxlYXZlIGZ1bmN0aW9ucyBhbG9uZSBhcyB0aGVzZSBzaG91bGQgYmVcbiAgICAgICAgICAvLyBjYWxsZWQgYXMgZXZlbnQubmF0aXZlRXZlbnQuZm4oKVxuICAgICAgICAgIGlmICh0eXBlb2YgcHJvcGVydHkgIT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICBleHRyYWN0RXZlbnRQcm9wc1twcm9wXSA9IHByb3BlcnR5O1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHJheWNhc3RFdmVudDogYW55ID0ge1xuICAgICAgICAgIC4uLmhpdCxcbiAgICAgICAgICAuLi5leHRyYWN0RXZlbnRQcm9wcyxcbiAgICAgICAgICBzcGFjZVg6IG1vdXNlLngsXG4gICAgICAgICAgc3BhY2VZOiBtb3VzZS55LFxuICAgICAgICAgIGludGVyc2VjdGlvbnMsXG4gICAgICAgICAgc3RvcHBlZDogbG9jYWxTdGF0ZS5zdG9wcGVkLFxuICAgICAgICAgIGRlbHRhLFxuICAgICAgICAgIHVucHJvamVjdGVkUG9pbnQsXG4gICAgICAgICAgcmF5OiByYXljYXN0ZXI/LnJheSxcbiAgICAgICAgICBjYW1lcmE6IGNhbWVyYSxcbiAgICAgICAgICAvLyBIaWphY2sgc3RvcFByb3BhZ2F0aW9uLCB3aGljaCBqdXN0IHNldHMgYSBmbGFnXG4gICAgICAgICAgc3RvcFByb3BhZ2F0aW9uOiAoKSA9PiB7XG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXRocmVlLWZpYmVyL2lzc3Vlcy81OTZcbiAgICAgICAgICAgIC8vIEV2ZW50cyBhcmUgbm90IGFsbG93ZWQgdG8gc3RvcCBwcm9wYWdhdGlvbiBpZiB0aGUgcG9pbnRlciBoYXMgYmVlbiBjYXB0dXJlZFxuICAgICAgICAgICAgY29uc3QgY2FwdHVyZXNGb3JQb2ludGVyID1cbiAgICAgICAgICAgICAgJ3BvaW50ZXJJZCcgaW4gZXZlbnQgJiYgaW50ZXJuYWwuY2FwdHVyZWRNYXAuZ2V0KGV2ZW50LnBvaW50ZXJJZCk7XG5cbiAgICAgICAgICAgIC8vIFdlIG9ubHkgYXV0aG9yaXplIHN0b3BQcm9wYWdhdGlvbi4uLlxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAvLyAuLi5pZiB0aGlzIHBvaW50ZXIgaGFzbid0IGJlZW4gY2FwdHVyZWRcbiAgICAgICAgICAgICAgIWNhcHR1cmVzRm9yUG9pbnRlciB8fFxuICAgICAgICAgICAgICAvLyAuLi4gb3IgaWYgdGhlIGhpdCBvYmplY3QgaXMgY2FwdHVyaW5nIHRoZSBwb2ludGVyXG4gICAgICAgICAgICAgIGNhcHR1cmVzRm9yUG9pbnRlci5oYXMoaGl0LmV2ZW50T2JqZWN0KVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHJheWNhc3RFdmVudC5zdG9wcGVkID0gbG9jYWxTdGF0ZS5zdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgLy8gUHJvcGFnYXRpb24gaXMgc3RvcHBlZCwgcmVtb3ZlIGFsbCBvdGhlciBob3ZlciByZWNvcmRzXG4gICAgICAgICAgICAgIC8vIEFuIGV2ZW50IGhhbmRsZXIgaXMgb25seSBhbGxvd2VkIHRvIGZsdXNoIG90aGVyIGhhbmRsZXJzIGlmIGl0IGlzIGhvdmVyZWQgaXRzZWxmXG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBpbnRlcm5hbC5ob3ZlcmVkLnNpemUgJiZcbiAgICAgICAgICAgICAgICBBcnJheS5mcm9tKGludGVybmFsLmhvdmVyZWQudmFsdWVzKCkpLmZpbmQoXG4gICAgICAgICAgICAgICAgICAoaSkgPT4gaS5ldmVudE9iamVjdCA9PT0gaGl0LmV2ZW50T2JqZWN0XG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAvLyBPYmplY3RzIGNhbm5vdCBmbHVzaCBvdXQgaGlnaGVyIHVwIG9iamVjdHMgdGhhdCBoYXZlIGFscmVhZHkgY2F1Z2h0IHRoZSBldmVudFxuICAgICAgICAgICAgICAgIGNvbnN0IGhpZ2hlciA9IGludGVyc2VjdGlvbnMuc2xpY2UoXG4gICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgaW50ZXJzZWN0aW9ucy5pbmRleE9mKGhpdClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGNhbmNlbFBvaW50ZXIoWy4uLmhpZ2hlciwgaGl0XSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIC8vIHRoZXJlIHNob3VsZCBiZSBhIGRpc3RpbmN0aW9uIGJldHdlZW4gdGFyZ2V0IGFuZCBjdXJyZW50VGFyZ2V0XG4gICAgICAgICAgdGFyZ2V0OiB7XG4gICAgICAgICAgICBoYXNQb2ludGVyQ2FwdHVyZSxcbiAgICAgICAgICAgIHNldFBvaW50ZXJDYXB0dXJlLFxuICAgICAgICAgICAgcmVsZWFzZVBvaW50ZXJDYXB0dXJlLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgY3VycmVudFRhcmdldDoge1xuICAgICAgICAgICAgaGFzUG9pbnRlckNhcHR1cmUsXG4gICAgICAgICAgICBzZXRQb2ludGVyQ2FwdHVyZSxcbiAgICAgICAgICAgIHJlbGVhc2VQb2ludGVyQ2FwdHVyZSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNvdXJjZUV2ZW50OiBldmVudCwgLy8gZGVwcmVjYXRlZFxuICAgICAgICAgIG5hdGl2ZUV2ZW50OiBldmVudCxcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBDYWxsIHN1YnNjcmliZXJzXG4gICAgICAgIGNhbGxiYWNrKHJheWNhc3RFdmVudCk7XG4gICAgICAgIC8vIEV2ZW50IGJ1YmJsaW5nIG1heSBiZSBpbnRlcnJ1cHRlZCBieSBzdG9wUHJvcGFnYXRpb25cbiAgICAgICAgaWYgKGxvY2FsU3RhdGUuc3RvcHBlZCkgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpbnRlcnNlY3Rpb25zO1xuICB9XG5cbiAgY29uc3QgaGFuZGxlUG9pbnRlciA9IChuYW1lOiBzdHJpbmcpID0+IHtcbiAgICAvLyBEZWFsIHdpdGggY2FuY2VsYXRpb25cbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgJ3BvaW50ZXJsZWF2ZSc6XG4gICAgICBjYXNlICdwb2ludGVyY2FuY2VsJzpcbiAgICAgICAgcmV0dXJuICgpID0+IGNhbmNlbFBvaW50ZXIoW10pO1xuICAgICAgY2FzZSAnb25Mb3N0UG9pbnRlckNhcHR1cmUnOlxuICAgICAgICByZXR1cm4gKGV2ZW50OiBOZ3REb21FdmVudCkgPT4ge1xuICAgICAgICAgIGlmICgncG9pbnRlcklkJyBpbiBldmVudCkge1xuICAgICAgICAgICAgLy8gSWYgdGhlIG9iamVjdCBldmVudCBpbnRlcmZhY2UgaGFkIG9uTG9zdFBvaW50ZXJDYXB0dXJlLCB3ZSdkIGNhbGwgaXQgaGVyZSBvbiBldmVyeVxuICAgICAgICAgICAgLy8gb2JqZWN0IHRoYXQncyBnZXR0aW5nIHJlbW92ZWQuXG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIGludGVybmFsOiB7IGNhcHR1cmVkTWFwIH0sXG4gICAgICAgICAgICB9ID0gZXZlbnRzU3RhdGVHZXR0ZXIoKTtcbiAgICAgICAgICAgIGNhcHR1cmVkTWFwLmRlbGV0ZShldmVudC5wb2ludGVySWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYW5jZWxQb2ludGVyKFtdKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBBbnkgb3RoZXIgcG9pbnRlciBnb2VzIGhlcmUgLi4uXG4gICAgcmV0dXJuIChldmVudDogTmd0RG9tRXZlbnQpID0+IHtcbiAgICAgIGNvbnN0IHsgcG9pbnRlck1pc3NlZCwgaW50ZXJuYWwgfSA9IGV2ZW50c1N0YXRlR2V0dGVyKCk7XG5cbiAgICAgIHByZXBhcmVSYXkoZXZlbnQpO1xuXG4gICAgICAvLyBHZXQgZnJlc2ggaW50ZXJzZWN0c1xuICAgICAgY29uc3QgaXNQb2ludGVyTW92ZSA9IG5hbWUgPT09ICdwb2ludGVybW92ZSc7XG4gICAgICBjb25zdCBpc0NsaWNrRXZlbnQgPVxuICAgICAgICBuYW1lID09PSAnY2xpY2snIHx8IG5hbWUgPT09ICdjb250ZXh0bWVudScgfHwgbmFtZSA9PT0gJ2RibGNsaWNrJztcbiAgICAgIGNvbnN0IGZpbHRlciA9IGlzUG9pbnRlck1vdmUgPyBmaWx0ZXJQb2ludGVyRXZlbnRzIDogdW5kZWZpbmVkO1xuICAgICAgY29uc3QgaGl0cyA9IHBhdGNoSW50ZXJzZWN0cyhpbnRlcnNlY3QoZmlsdGVyKSwgZXZlbnQpO1xuXG4gICAgICBjb25zdCBkZWx0YSA9IGlzQ2xpY2tFdmVudCA/IGNhbGN1bGF0ZURpc3RhbmNlKGV2ZW50KSA6IDA7XG4gICAgICAvLyBTYXZlIGluaXRpYWwgY29vcmRpbmF0ZXMgb24gcG9pbnRlci1kb3duXG4gICAgICBpZiAobmFtZSA9PT0gJ3BvaW50ZXJkb3duJykge1xuICAgICAgICBpbnRlcm5hbC5pbml0aWFsQ2xpY2sgPSBbZXZlbnQub2Zmc2V0WCwgZXZlbnQub2Zmc2V0WV07XG4gICAgICAgIGludGVybmFsLmluaXRpYWxIaXRzID0gaGl0cy5tYXAoKGhpdCkgPT4gaGl0LmV2ZW50T2JqZWN0KTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgYSBjbGljayB5aWVsZHMgbm8gcmVzdWx0cywgcGFzcyBpdCBiYWNrIHRvIHRoZSB1c2VyIGFzIGEgbWlzc1xuICAgICAgLy8gTWlzc2VkIGV2ZW50cyBoYXZlIHRvIGNvbWUgZmlyc3QgaW4gb3JkZXIgdG8gZXN0YWJsaXNoIHVzZXItbGFuZCBzaWRlLWVmZmVjdCBjbGVhbiB1cFxuICAgICAgaWYgKGlzQ2xpY2tFdmVudCAmJiAhaGl0cy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKGRlbHRhIDw9IDIpIHtcbiAgICAgICAgICBvYmplY3RQb2ludGVyTWlzc2VkKGV2ZW50LCBpbnRlcm5hbC5pbnRlcmFjdGlvbik7XG4gICAgICAgICAgaWYgKHBvaW50ZXJNaXNzZWQpIHBvaW50ZXJNaXNzZWQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBUYWtlIGNhcmUgb2YgdW5ob3ZlclxuICAgICAgaWYgKGlzUG9pbnRlck1vdmUpIGNhbmNlbFBvaW50ZXIoaGl0cyk7XG5cbiAgICAgIGhhbmRsZUludGVyc2VjdHMoaGl0cywgZXZlbnQsIGRlbHRhLCAoZGF0YTogTmd0RXZlbnQ8Tmd0RG9tRXZlbnQ+KSA9PiB7XG4gICAgICAgIGNvbnN0IGV2ZW50T2JqZWN0ID0gZGF0YS5ldmVudE9iamVjdDtcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSAoZXZlbnRPYmplY3QgYXMgdW5rbm93biBhcyBOZ3RJbnN0YW5jZSkuX19uZ3Q7XG4gICAgICAgIGNvbnN0IGhhbmRsZXJzID0gaW5zdGFuY2U/LmhhbmRsZXJzO1xuXG4gICAgICAgIC8vIENoZWNrIHByZXNlbmNlIG9mIGhhbmRsZXJzXG4gICAgICAgIGlmICghaW5zdGFuY2U/LmV2ZW50Q291bnQpIHJldHVybjtcblxuICAgICAgICBpZiAoaXNQb2ludGVyTW92ZSkge1xuICAgICAgICAgIC8vIE1vdmUgZXZlbnQgLi4uXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgaGFuZGxlcnM/LnBvaW50ZXJvdmVyIHx8XG4gICAgICAgICAgICBoYW5kbGVycz8ucG9pbnRlcmVudGVyIHx8XG4gICAgICAgICAgICBoYW5kbGVycz8ucG9pbnRlcm91dCB8fFxuICAgICAgICAgICAgaGFuZGxlcnM/LnBvaW50ZXJsZWF2ZVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgLy8gV2hlbiBlbnRlciBvciBvdXQgaXMgcHJlc2VudCB0YWtlIGNhcmUgb2YgaG92ZXItc3RhdGVcbiAgICAgICAgICAgIGNvbnN0IGlkID0gbWFrZUlkKGRhdGEpO1xuICAgICAgICAgICAgY29uc3QgaG92ZXJlZEl0ZW0gPSBpbnRlcm5hbC5ob3ZlcmVkLmdldChpZCk7XG4gICAgICAgICAgICBpZiAoIWhvdmVyZWRJdGVtKSB7XG4gICAgICAgICAgICAgIC8vIElmIHRoZSBvYmplY3Qgd2Fzbid0IHByZXZpb3VzbHkgaG92ZXJlZCwgYm9vayBpdCBhbmQgY2FsbCBpdHMgaGFuZGxlclxuICAgICAgICAgICAgICBpbnRlcm5hbC5ob3ZlcmVkLnNldChpZCwgZGF0YSk7XG4gICAgICAgICAgICAgIGhhbmRsZXJzLnBvaW50ZXJvdmVyPy4oZGF0YSBhcyBOZ3RFdmVudDxQb2ludGVyRXZlbnQ+KTtcbiAgICAgICAgICAgICAgaGFuZGxlcnMucG9pbnRlcmVudGVyPy4oZGF0YSBhcyBOZ3RFdmVudDxQb2ludGVyRXZlbnQ+KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaG92ZXJlZEl0ZW0uc3RvcHBlZCkge1xuICAgICAgICAgICAgICAvLyBJZiB0aGUgb2JqZWN0IHdhcyBwcmV2aW91c2x5IGhvdmVyZWQgYW5kIHN0b3BwZWQsIHdlIHNob3VsZG4ndCBhbGxvdyBvdGhlciBpdGVtcyB0byBwcm9jZWVkXG4gICAgICAgICAgICAgIGRhdGEuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIENhbGwgbW91c2UgbW92ZVxuICAgICAgICAgIGhhbmRsZXJzPy5wb2ludGVybW92ZT8uKGRhdGEgYXMgTmd0RXZlbnQ8UG9pbnRlckV2ZW50Pik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gQWxsIG90aGVyIGV2ZW50cyAuLi5cbiAgICAgICAgICBjb25zdCBoYW5kbGVyID0gaGFuZGxlcnM/LltuYW1lIGFzIGtleW9mIE5ndEV2ZW50SGFuZGxlcnNdIGFzIChcbiAgICAgICAgICAgIGV2ZW50OiBOZ3RFdmVudDxQb2ludGVyRXZlbnQ+XG4gICAgICAgICAgKSA9PiB2b2lkO1xuICAgICAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgICAvLyBGb3J3YXJkIGFsbCBldmVudHMgYmFjayB0byB0aGVpciByZXNwZWN0aXZlIGhhbmRsZXJzIHdpdGggdGhlIGV4Y2VwdGlvbiBvZiBjbGljayBldmVudHMsXG4gICAgICAgICAgICAvLyB3aGljaCBtdXN0IHVzZSB0aGUgaW5pdGlhbCB0YXJnZXRcbiAgICAgICAgICAgIGlmICghaXNDbGlja0V2ZW50IHx8IGludGVybmFsLmluaXRpYWxIaXRzLmluY2x1ZGVzKGV2ZW50T2JqZWN0KSkge1xuICAgICAgICAgICAgICAvLyBNaXNzZWQgZXZlbnRzIGhhdmUgdG8gY29tZSBmaXJzdFxuICAgICAgICAgICAgICBvYmplY3RQb2ludGVyTWlzc2VkKFxuICAgICAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgICAgIGludGVybmFsLmludGVyYWN0aW9uLmZpbHRlcihcbiAgICAgICAgICAgICAgICAgIChvYmplY3QpID0+ICFpbnRlcm5hbC5pbml0aWFsSGl0cy5pbmNsdWRlcyhvYmplY3QpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAvLyBOb3cgY2FsbCB0aGUgaGFuZGxlclxuICAgICAgICAgICAgICBoYW5kbGVyKGRhdGEgYXMgTmd0RXZlbnQ8UG9pbnRlckV2ZW50Pik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIG9iamVjdFBvaW50ZXJNaXNzZWQoZXZlbnQ6IE1vdXNlRXZlbnQsIG9iamVjdHM6IFRIUkVFLk9iamVjdDNEW10pIHtcbiAgICBvYmplY3RzLmZvckVhY2goKG9iamVjdDogVEhSRUUuT2JqZWN0M0QpID0+XG4gICAgICAob2JqZWN0IGFzIHVua25vd24gYXMgTmd0SW5zdGFuY2UpLl9fbmd0Py5oYW5kbGVycz8ucG9pbnRlcm1pc3NlZD8uKGV2ZW50KVxuICAgICk7XG4gIH1cblxuICByZXR1cm4geyBoYW5kbGVQb2ludGVyIH07XG59XG4iXX0=