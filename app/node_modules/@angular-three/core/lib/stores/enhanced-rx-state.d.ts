import { RxState } from '@rx-angular/state';
import { Observable } from 'rxjs';
import * as i0 from "@angular/core";
export declare abstract class EnhancedRxState<T extends object = {}> extends RxState<T> {
    private effect$;
    private effectSubscription;
    ngOnDestroy(): void;
    holdEffect<S>(obsOrObsWithSideEffect: Observable<S>, sideEffectFn: (value: S, firstRun: boolean) => ((previousValue: S | undefined, isUnsubscribed: boolean) => void) | void): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<EnhancedRxState<any>, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<EnhancedRxState<any>, never, never, {}, {}, never>;
}
export declare function capitalize<T extends string>(str: T): Capitalize<T>;
declare type InstanceOrType<T> = T extends abstract new (...args: unknown[]) => infer R ? R : T;
export declare type ActionAccess<T extends {
    [x: string]: any;
}> = {
    [K in keyof T]: (arg: InstanceOrType<T[K]>) => void;
} & {
    [K in Extract<keyof T, string> as `${K}$`]: Observable<T[K]>;
};
/**
 * Returns a object based off of the provided typing with a separate setter `[prop](value: T[K]): void` and observable stream `[prop]$: Observable<T[K]>`;
 *
 * { search: string } => { search$: Observable<string>, search: (value: string) => void;}
 *
 * @example
 *
 * const actions = getActions<search: string, submit: void>({search: (e) => e.target.value});
 *
 * actions.search($event);
 * actions.search$ | async;
 *
 * @param transforms map of transform functions to apply on certain properties if they are set.
 */
export declare function getActions<T extends object>(): ActionAccess<T>;
export {};
