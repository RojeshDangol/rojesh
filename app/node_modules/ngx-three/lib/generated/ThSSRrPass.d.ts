import { Type } from '@angular/core';
import { Camera, Color, ColorRepresentation, Material, Mesh, MeshBasicMaterial, MeshNormalMaterial, MeshStandardMaterial, Scene, ShaderMaterial, WebGLRenderer, WebGLRenderTarget } from 'three';
import { FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass';
import { SSRrPass, SSRrPassParams } from 'three/examples/jsm/postprocessing/SSRrPass';
import { ThPass } from './ThPass';
import * as i0 from "@angular/core";
export declare class ThSSRrPass<T extends SSRrPass = SSRrPass, TARGS = SSRrPassParams> extends ThPass<T, TARGS> {
    getType(): Type<SSRrPass>;
    set width(value: number);
    set height(value: number);
    set clear(value: boolean);
    set renderer(value: WebGLRenderer);
    set scene(value: Scene);
    set camera(value: Camera);
    set output(value: number);
    set ior(value: number);
    set maxDistance(value: number);
    set surfDist(value: number);
    set color(value: Color | [color: ColorRepresentation]);
    set seleects(value: Mesh[] | null);
    set _specular(value: boolean);
    set _fillHole(value: boolean);
    set _infiniteThick(value: boolean);
    set beautyRenderTarget(value: WebGLRenderTarget);
    set specularRenderTarget(value: WebGLRenderTarget);
    set normalSelectsRenderTarget(value: WebGLRenderTarget);
    set refractiveRenderTarget(value: WebGLRenderTarget);
    set ssrrRenderTarget(value: WebGLRenderTarget);
    set ssrrMaterial(value: ShaderMaterial);
    set normalMaterial(value: MeshNormalMaterial);
    set refractiveOnMaterial(value: MeshBasicMaterial);
    set refractiveOffMaterial(value: MeshBasicMaterial);
    set specularMaterial(value: MeshStandardMaterial);
    set depthRenderMaterial(value: ShaderMaterial);
    set copyMaterial(value: ShaderMaterial);
    set fsQuad(value: FullScreenQuad);
    set originalClearColor(value: Color | [color: ColorRepresentation]);
    set dispose(value: () => void);
    set render(value: (renderer: WebGLRenderer, writeBuffer: WebGLRenderTarget) => void);
    set renderPass(value: (renderer: WebGLRenderer, passMaterial: Material, renderTarget: WebGLRenderTarget, clearColor: ColorRepresentation, clearAlpha: ColorRepresentation) => void);
    set renderOverride(value: (renderer: WebGLRenderer, passMaterial: Material, renderTarget: WebGLRenderTarget, clearColor: ColorRepresentation, clearAlpha: ColorRepresentation) => void);
    set renderRefractive(value: (renderer: WebGLRenderer, passMaterial: Material, renderTarget: WebGLRenderTarget, clearColor: ColorRepresentation, clearAlpha: ColorRepresentation) => void);
    set setSize(value: (width: number, height: number) => void);
    static ɵfac: i0.ɵɵFactoryDeclaration<ThSSRrPass<any, any>, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<ThSSRrPass<any, any>, "th-sSRrPass", never, { "width": "width"; "height": "height"; "clear": "clear"; "renderer": "renderer"; "scene": "scene"; "camera": "camera"; "output": "output"; "ior": "ior"; "maxDistance": "maxDistance"; "surfDist": "surfDist"; "color": "color"; "seleects": "seleects"; "_specular": "_specular"; "_fillHole": "_fillHole"; "_infiniteThick": "_infiniteThick"; "beautyRenderTarget": "beautyRenderTarget"; "specularRenderTarget": "specularRenderTarget"; "normalSelectsRenderTarget": "normalSelectsRenderTarget"; "refractiveRenderTarget": "refractiveRenderTarget"; "ssrrRenderTarget": "ssrrRenderTarget"; "ssrrMaterial": "ssrrMaterial"; "normalMaterial": "normalMaterial"; "refractiveOnMaterial": "refractiveOnMaterial"; "refractiveOffMaterial": "refractiveOffMaterial"; "specularMaterial": "specularMaterial"; "depthRenderMaterial": "depthRenderMaterial"; "copyMaterial": "copyMaterial"; "fsQuad": "fsQuad"; "originalClearColor": "originalClearColor"; "dispose": "dispose"; "render": "render"; "renderPass": "renderPass"; "renderOverride": "renderOverride"; "renderRefractive": "renderRefractive"; "setSize": "setSize"; }, {}, never, never>;
}
