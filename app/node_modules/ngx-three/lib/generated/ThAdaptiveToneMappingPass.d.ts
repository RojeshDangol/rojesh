import { Type } from '@angular/core';
import { ShaderMaterial, WebGLRenderTarget } from 'three';
import { AdaptiveToneMappingPass } from 'three/examples/jsm/postprocessing/AdaptiveToneMappingPass';
import { ThPass } from './ThPass';
import * as i0 from "@angular/core";
export declare class ThAdaptiveToneMappingPass<T extends AdaptiveToneMappingPass = AdaptiveToneMappingPass, TARGS = [adaptive?: boolean, resolution?: number]> extends ThPass<T, TARGS> {
    getType(): Type<AdaptiveToneMappingPass>;
    set adaptive(value: boolean);
    set resolution(value: number);
    set needsInit(value: number);
    set luminanceRT(value: WebGLRenderTarget);
    set previousLuminanceRT(value: WebGLRenderTarget);
    set currentLuminanceRT(value: WebGLRenderTarget);
    set copyUniforms(value: object);
    set materialCopy(value: ShaderMaterial);
    set materialLuminance(value: ShaderMaterial);
    set adaptLuminanceShader(value: object);
    set materialAdaptiveLum(value: ShaderMaterial);
    set materialToneMap(value: ShaderMaterial);
    set fsQuad(value: object);
    static ɵfac: i0.ɵɵFactoryDeclaration<ThAdaptiveToneMappingPass<any, any>, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<ThAdaptiveToneMappingPass<any, any>, "th-adaptiveToneMappingPass", never, { "adaptive": "adaptive"; "resolution": "resolution"; "needsInit": "needsInit"; "luminanceRT": "luminanceRT"; "previousLuminanceRT": "previousLuminanceRT"; "currentLuminanceRT": "currentLuminanceRT"; "copyUniforms": "copyUniforms"; "materialCopy": "materialCopy"; "materialLuminance": "materialLuminance"; "adaptLuminanceShader": "adaptLuminanceShader"; "materialAdaptiveLum": "materialAdaptiveLum"; "materialToneMap": "materialToneMap"; "fsQuad": "fsQuad"; }, {}, never, never>;
}
